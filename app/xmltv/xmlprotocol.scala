// Generated by <a href="http://scalaxb.org/">scalaxb</a>.
package xmltv
    
/**
usage:
val obj = scalaxb.fromXML[xmltv.Foo](node)
val document = scalaxb.toXML[xmltv.Foo](obj, "foo", xmltv.defaultScope)
**/
object `package` extends XMLProtocol { }

trait XMLProtocol extends scalaxb.XMLStandardTypes {
  val defaultScope = scalaxb.toScope(Some("xs") -> "http://www.w3.org/2001/XMLSchema",
    Some("xsi") -> "http://www.w3.org/2001/XMLSchema-instance")
  implicit lazy val XmltvTvFormat: scalaxb.XMLFormat[xmltv.Tv] = new DefaultXmltvTvFormat {}
  implicit lazy val XmltvChannelFormat: scalaxb.XMLFormat[xmltv.Channel] = new DefaultXmltvChannelFormat {}
  implicit lazy val XmltvDisplayu45nameFormat: scalaxb.XMLFormat[xmltv.Displayu45name] = new DefaultXmltvDisplayu45nameFormat {}
  implicit lazy val XmltvProgrammeFormat: scalaxb.XMLFormat[xmltv.Programme] = new DefaultXmltvProgrammeFormat {}
  implicit lazy val XmltvProgrammeSequence1Format: scalaxb.XMLFormat[xmltv.ProgrammeSequence1] = new DefaultXmltvProgrammeSequence1Format {}
  implicit lazy val XmltvProgrammeSequence2Format: scalaxb.XMLFormat[xmltv.ProgrammeSequence2] = new DefaultXmltvProgrammeSequence2Format {}
  implicit lazy val XmltvProgrammeSequence3Format: scalaxb.XMLFormat[xmltv.ProgrammeSequence3] = new DefaultXmltvProgrammeSequence3Format {}
  implicit lazy val XmltvTitleFormat: scalaxb.XMLFormat[xmltv.Title] = new DefaultXmltvTitleFormat {}
  implicit lazy val XmltvSubu45titleFormat: scalaxb.XMLFormat[xmltv.Subu45title] = new DefaultXmltvSubu45titleFormat {}
  implicit lazy val XmltvDescFormat: scalaxb.XMLFormat[xmltv.Desc] = new DefaultXmltvDescFormat {}
  implicit lazy val XmltvCreditsFormat: scalaxb.XMLFormat[xmltv.Credits] = new DefaultXmltvCreditsFormat {}
  implicit lazy val XmltvActorFormat: scalaxb.XMLFormat[xmltv.Actor] = new DefaultXmltvActorFormat {}
  implicit lazy val XmltvCategoryFormat: scalaxb.XMLFormat[xmltv.Category] = new DefaultXmltvCategoryFormat {}
  implicit lazy val XmltvLanguageFormat: scalaxb.XMLFormat[xmltv.Language] = new DefaultXmltvLanguageFormat {}
  implicit lazy val XmltvOrigu45languageFormat: scalaxb.XMLFormat[xmltv.Origu45language] = new DefaultXmltvOrigu45languageFormat {}
  implicit lazy val XmltvLengthFormat: scalaxb.XMLFormat[xmltv.Length] = new DefaultXmltvLengthFormat {}
  implicit lazy val XmltvUnitsFormat: scalaxb.XMLFormat[xmltv.Units] = new DefaultXmltvUnitsFormat {}
  implicit lazy val XmltvIconFormat: scalaxb.XMLFormat[xmltv.Icon] = new DefaultXmltvIconFormat {}
  implicit lazy val XmltvCountryFormat: scalaxb.XMLFormat[xmltv.Country] = new DefaultXmltvCountryFormat {}
  implicit lazy val XmltvEpisodeu45numFormat: scalaxb.XMLFormat[xmltv.Episodeu45num] = new DefaultXmltvEpisodeu45numFormat {}
  implicit lazy val XmltvVideoFormat: scalaxb.XMLFormat[xmltv.Video] = new DefaultXmltvVideoFormat {}
  implicit lazy val XmltvAudioFormat: scalaxb.XMLFormat[xmltv.Audio] = new DefaultXmltvAudioFormat {}
  implicit lazy val XmltvPreviouslyu45shownFormat: scalaxb.XMLFormat[xmltv.Previouslyu45shown] = new DefaultXmltvPreviouslyu45shownFormat {}
  implicit lazy val XmltvPremiereFormat: scalaxb.XMLFormat[xmltv.Premiere] = new DefaultXmltvPremiereFormat {}
  implicit lazy val XmltvLastu45chanceFormat: scalaxb.XMLFormat[xmltv.Lastu45chance] = new DefaultXmltvLastu45chanceFormat {}
  implicit lazy val XmltvNewFormat: scalaxb.XMLFormat[xmltv.New] = new DefaultXmltvNewFormat {}
  implicit lazy val XmltvSubtitlesFormat: scalaxb.XMLFormat[xmltv.Subtitles] = new DefaultXmltvSubtitlesFormat {}
  implicit lazy val XmltvTypeFormat: scalaxb.XMLFormat[xmltv.Type] = new DefaultXmltvTypeFormat {}
  implicit lazy val XmltvRatingFormat: scalaxb.XMLFormat[xmltv.Rating] = new DefaultXmltvRatingFormat {}
  implicit lazy val XmltvStaru45ratingFormat: scalaxb.XMLFormat[xmltv.Staru45rating] = new DefaultXmltvStaru45ratingFormat {}
  implicit lazy val XmltvReviewFormat: scalaxb.XMLFormat[xmltv.Review] = new DefaultXmltvReviewFormat {}
  implicit lazy val XmltvTypeTypeFormat: scalaxb.XMLFormat[xmltv.TypeType] = new DefaultXmltvTypeTypeFormat {}
  implicit lazy val XmltvAttlistu46reviewFormat: scalaxb.AttributeGroupFormat[xmltv.Attlistu46review] = new DefaultXmltvAttlistu46reviewFormat {}
  implicit lazy val XmltvAttlistu46staru45ratingFormat: scalaxb.AttributeGroupFormat[xmltv.Attlistu46staru45rating] = new DefaultXmltvAttlistu46staru45ratingFormat {}
  implicit lazy val XmltvAttlistu46ratingFormat: scalaxb.AttributeGroupFormat[xmltv.Attlistu46rating] = new DefaultXmltvAttlistu46ratingFormat {}
  implicit lazy val XmltvAttlistu46subtitlesFormat: scalaxb.AttributeGroupFormat[xmltv.Attlistu46subtitles] = new DefaultXmltvAttlistu46subtitlesFormat {}
  implicit lazy val XmltvAttlistu46lastu45chanceFormat: scalaxb.AttributeGroupFormat[xmltv.Attlistu46lastu45chance] = new DefaultXmltvAttlistu46lastu45chanceFormat {}
  implicit lazy val XmltvAttlistu46premiereFormat: scalaxb.AttributeGroupFormat[xmltv.Attlistu46premiere] = new DefaultXmltvAttlistu46premiereFormat {}
  implicit lazy val XmltvAttlistu46previouslyu45shownFormat: scalaxb.AttributeGroupFormat[xmltv.Attlistu46previouslyu45shown] = new DefaultXmltvAttlistu46previouslyu45shownFormat {}
  implicit lazy val XmltvAttlistu46episodeu45numFormat: scalaxb.AttributeGroupFormat[xmltv.Attlistu46episodeu45num] = new DefaultXmltvAttlistu46episodeu45numFormat {}
  implicit lazy val XmltvAttlistu46countryFormat: scalaxb.AttributeGroupFormat[xmltv.Attlistu46country] = new DefaultXmltvAttlistu46countryFormat {}
  implicit lazy val XmltvAttlistu46iconFormat: scalaxb.AttributeGroupFormat[xmltv.Attlistu46icon] = new DefaultXmltvAttlistu46iconFormat {}
  implicit lazy val XmltvAttlistu46lengthFormat: scalaxb.AttributeGroupFormat[xmltv.Attlistu46length] = new DefaultXmltvAttlistu46lengthFormat {}
  implicit lazy val XmltvAttlistu46origu45languageFormat: scalaxb.AttributeGroupFormat[xmltv.Attlistu46origu45language] = new DefaultXmltvAttlistu46origu45languageFormat {}
  implicit lazy val XmltvAttlistu46languageFormat: scalaxb.AttributeGroupFormat[xmltv.Attlistu46language] = new DefaultXmltvAttlistu46languageFormat {}
  implicit lazy val XmltvAttlistu46categoryFormat: scalaxb.AttributeGroupFormat[xmltv.Attlistu46category] = new DefaultXmltvAttlistu46categoryFormat {}
  implicit lazy val XmltvAttlistu46actorFormat: scalaxb.AttributeGroupFormat[xmltv.Attlistu46actor] = new DefaultXmltvAttlistu46actorFormat {}
  implicit lazy val XmltvAttlistu46descFormat: scalaxb.AttributeGroupFormat[xmltv.Attlistu46desc] = new DefaultXmltvAttlistu46descFormat {}
  implicit lazy val XmltvAttlistu46subu45titleFormat: scalaxb.AttributeGroupFormat[xmltv.Attlistu46subu45title] = new DefaultXmltvAttlistu46subu45titleFormat {}
  implicit lazy val XmltvAttlistu46titleFormat: scalaxb.AttributeGroupFormat[xmltv.Attlistu46title] = new DefaultXmltvAttlistu46titleFormat {}
  implicit lazy val XmltvAttlistu46programmeFormat: scalaxb.AttributeGroupFormat[xmltv.Attlistu46programme] = new DefaultXmltvAttlistu46programmeFormat {}
  implicit lazy val XmltvAttlistu46displayu45nameFormat: scalaxb.AttributeGroupFormat[xmltv.Attlistu46displayu45name] = new DefaultXmltvAttlistu46displayu45nameFormat {}
  implicit lazy val XmltvAttlistu46channelFormat: scalaxb.AttributeGroupFormat[xmltv.Attlistu46channel] = new DefaultXmltvAttlistu46channelFormat {}
  implicit lazy val XmltvAttlistu46tvFormat: scalaxb.AttributeGroupFormat[xmltv.Attlistu46tv] = new DefaultXmltvAttlistu46tvFormat {}

  trait DefaultXmltvTvFormat extends scalaxb.ElemNameParser[xmltv.Tv] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[xmltv.Tv] =
      phrase(rep(scalaxb.ElemName(None, "channel")) ~ 
      rep(scalaxb.ElemName(None, "programme")) ^^
      { case p1 ~ p2 =>
      xmltv.Tv(p1.toSeq map { scalaxb.fromXML[xmltv.Channel](_, scalaxb.ElemName(node) :: stack) },
        p2.toSeq map { scalaxb.fromXML[xmltv.Programme](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@date").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@source-info-url").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@source-info-name").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@source-data-url").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@generator-info-name").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@generator-info-url").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }) })
    
    override def writesAttribute(__obj: xmltv.Tv, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.date foreach { x => attr = scala.xml.Attribute(null, "date", x.toString, attr) }
      __obj.sourceu45infou45url foreach { x => attr = scala.xml.Attribute(null, "source-info-url", x.toString, attr) }
      __obj.sourceu45infou45name foreach { x => attr = scala.xml.Attribute(null, "source-info-name", x.toString, attr) }
      __obj.sourceu45datau45url foreach { x => attr = scala.xml.Attribute(null, "source-data-url", x.toString, attr) }
      __obj.generatoru45infou45name foreach { x => attr = scala.xml.Attribute(null, "generator-info-name", x.toString, attr) }
      __obj.generatoru45infou45url foreach { x => attr = scala.xml.Attribute(null, "generator-info-url", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: xmltv.Tv, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.channel flatMap { scalaxb.toXML[xmltv.Channel](_, None, Some("channel"), __scope, false) },
        __obj.programme flatMap { scalaxb.toXML[xmltv.Programme](_, None, Some("programme"), __scope, false) })

  }

  trait DefaultXmltvChannelFormat extends scalaxb.ElemNameParser[xmltv.Channel] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[xmltv.Channel] =
      phrase(rep(scalaxb.ElemName(None, "display-name")) ~ 
      rep(scalaxb.ElemName(None, "icon")) ~ 
      rep(scalaxb.ElemName(None, "url")) ^^
      { case p1 ~ p2 ~ p3 =>
      xmltv.Channel(p1.toSeq map { scalaxb.fromXML[xmltv.Displayu45name](_, scalaxb.ElemName(node) :: stack) },
        p2.toSeq map { scalaxb.fromXML[xmltv.Icon](_, scalaxb.ElemName(node) :: stack) },
        p3.toSeq map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[String]((node \ "@id"), scalaxb.ElemName(node) :: stack)) })
    
    override def writesAttribute(__obj: xmltv.Channel, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "id", __obj.id.toString, attr)
      attr
    }
    def writesChildNodes(__obj: xmltv.Channel, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.displayu45name flatMap { scalaxb.toXML[xmltv.Displayu45name](_, None, Some("display-name"), __scope, false) },
        __obj.icon flatMap { scalaxb.toXML[xmltv.Icon](_, None, Some("icon"), __scope, false) },
        __obj.url flatMap { scalaxb.toXML[String](_, None, Some("url"), __scope, false) })

  }

  trait DefaultXmltvDisplayu45nameFormat extends scalaxb.ElemNameParser[xmltv.Displayu45name] {
    val targetNamespace: Option[String] = None
    
    override def isMixed: Boolean = true

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[xmltv.Displayu45name] =
      phrase(optTextRecord ^^
      { case p1 =>
      xmltv.Displayu45name(Seq.concat(p1.toList),
        (node \ "@lang").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }) })
    
    override def writesAttribute(__obj: xmltv.Displayu45name, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.lang foreach { x => attr = scala.xml.Attribute(null, "lang", x.toString, attr) }
      attr
    }
    def writesChildNodes(__obj: xmltv.Displayu45name, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      __obj.mixed.toSeq flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) }
  }

  trait DefaultXmltvProgrammeFormat extends scalaxb.ElemNameParser[xmltv.Programme] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[xmltv.Programme] =
      phrase(((rep(scalaxb.ElemName(None, "title")) ~ 
      rep(scalaxb.ElemName(None, "sub-title")) ~ 
      rep(scalaxb.ElemName(None, "desc")) ~ 
      opt(scalaxb.ElemName(None, "credits")) ~ 
      opt(scalaxb.ElemName(None, "date")) ~ 
      rep(scalaxb.ElemName(None, "category")) ~ 
      opt(scalaxb.ElemName(None, "language")) ~ 
      opt(scalaxb.ElemName(None, "orig-language")) ~ 
      opt(scalaxb.ElemName(None, "length")) ~ 
      rep(scalaxb.ElemName(None, "icon"))) ^^ 
        { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 ~ p9 ~ p10 => xmltv.ProgrammeSequence1(p1.toSeq map { scalaxb.fromXML[xmltv.Title](_, scalaxb.ElemName(node) :: stack) },
        p2.toSeq map { scalaxb.fromXML[xmltv.Subu45title](_, scalaxb.ElemName(node) :: stack) },
        p3.toSeq map { scalaxb.fromXML[xmltv.Desc](_, scalaxb.ElemName(node) :: stack) },
        p4.headOption map { scalaxb.fromXML[xmltv.Credits](_, scalaxb.ElemName(node) :: stack) },
        p5.headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        p6.toSeq map { scalaxb.fromXML[xmltv.Category](_, scalaxb.ElemName(node) :: stack) },
        p7.headOption map { scalaxb.fromXML[xmltv.Language](_, scalaxb.ElemName(node) :: stack) },
        p8.headOption map { scalaxb.fromXML[xmltv.Origu45language](_, scalaxb.ElemName(node) :: stack) },
        p9.headOption map { scalaxb.fromXML[xmltv.Length](_, scalaxb.ElemName(node) :: stack) },
        p10.toSeq map { scalaxb.fromXML[xmltv.Icon](_, scalaxb.ElemName(node) :: stack) }) }) ~ 
      ((rep(scalaxb.ElemName(None, "url")) ~ 
      rep(scalaxb.ElemName(None, "country")) ~ 
      rep(scalaxb.ElemName(None, "episode-num")) ~ 
      opt(scalaxb.ElemName(None, "video")) ~ 
      opt(scalaxb.ElemName(None, "audio")) ~ 
      opt(scalaxb.ElemName(None, "previously-shown")) ~ 
      opt(scalaxb.ElemName(None, "premiere")) ~ 
      opt(scalaxb.ElemName(None, "last-chance")) ~ 
      opt(scalaxb.ElemName(None, "new")) ~ 
      rep(scalaxb.ElemName(None, "subtitles"))) ^^ 
        { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 ~ p9 ~ p10 => xmltv.ProgrammeSequence2(p1.toSeq map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        p2.toSeq map { scalaxb.fromXML[xmltv.Country](_, scalaxb.ElemName(node) :: stack) },
        p3.toSeq map { scalaxb.fromXML[xmltv.Episodeu45num](_, scalaxb.ElemName(node) :: stack) },
        p4.headOption map { scalaxb.fromXML[xmltv.Video](_, scalaxb.ElemName(node) :: stack) },
        p5.headOption map { scalaxb.fromXML[xmltv.Audio](_, scalaxb.ElemName(node) :: stack) },
        p6.headOption map { scalaxb.fromXML[xmltv.Previouslyu45shown](_, scalaxb.ElemName(node) :: stack) },
        p7.headOption map { scalaxb.fromXML[xmltv.Premiere](_, scalaxb.ElemName(node) :: stack) },
        p8.headOption map { scalaxb.fromXML[xmltv.Lastu45chance](_, scalaxb.ElemName(node) :: stack) },
        p9.headOption map { scalaxb.fromXML[xmltv.New](_, scalaxb.ElemName(node) :: stack) },
        p10.toSeq map { scalaxb.fromXML[xmltv.Subtitles](_, scalaxb.ElemName(node) :: stack) }) }) ~ 
      ((rep(scalaxb.ElemName(None, "rating")) ~ 
      rep(scalaxb.ElemName(None, "star-rating")) ~ 
      rep(scalaxb.ElemName(None, "review"))) ^^ 
        { case p1 ~ p2 ~ p3 => xmltv.ProgrammeSequence3(p1.toSeq map { scalaxb.fromXML[xmltv.Rating](_, scalaxb.ElemName(node) :: stack) },
        p2.toSeq map { scalaxb.fromXML[xmltv.Staru45rating](_, scalaxb.ElemName(node) :: stack) },
        p3.toSeq map { scalaxb.fromXML[xmltv.Review](_, scalaxb.ElemName(node) :: stack) }) }) ^^
      { case p1 ~ p2 ~ p3 =>
      xmltv.Programme(p1,
        p2,
        p3,
        scalaxb.fromXML[String]((node \ "@start"), scalaxb.ElemName(node) :: stack),
        (node \ "@stop").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@pdc-start").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@vps-start").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@showview").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@videoplus").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[String]((node \ "@channel"), scalaxb.ElemName(node) :: stack),
        (node \ "@clumpidx").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[String](scala.xml.Text("0/1"), scalaxb.ElemName(node) :: stack) }) })
    
    override def writesAttribute(__obj: xmltv.Programme, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "start", __obj.start.toString, attr)
      __obj.stop foreach { x => attr = scala.xml.Attribute(null, "stop", x.toString, attr) }
      __obj.pdcu45start foreach { x => attr = scala.xml.Attribute(null, "pdc-start", x.toString, attr) }
      __obj.vpsu45start foreach { x => attr = scala.xml.Attribute(null, "vps-start", x.toString, attr) }
      __obj.showview foreach { x => attr = scala.xml.Attribute(null, "showview", x.toString, attr) }
      __obj.videoplus foreach { x => attr = scala.xml.Attribute(null, "videoplus", x.toString, attr) }
      attr = scala.xml.Attribute(null, "channel", __obj.channel.toString, attr)
      if (__obj.clumpidx.toString != "0/1") attr = scala.xml.Attribute(null, "clumpidx", __obj.clumpidx.toString, attr)
      attr
    }

    def writesChildNodes(__obj: xmltv.Programme, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(scalaxb.toXML[xmltv.ProgrammeSequence1](__obj.programmesequence1, None, Some("programmesequence1"), __scope, false),
        scalaxb.toXML[xmltv.ProgrammeSequence2](__obj.programmesequence2, None, Some("programmesequence2"), __scope, false),
        scalaxb.toXML[xmltv.ProgrammeSequence3](__obj.programmesequence3, None, Some("programmesequence3"), __scope, false))

  }

  trait DefaultXmltvProgrammeSequence1Format extends scalaxb.XMLFormat[xmltv.ProgrammeSequence1] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, xmltv.ProgrammeSequence1] = Left("don't call me.")
    
    def writes(__obj: xmltv.ProgrammeSequence1, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(__obj.title flatMap { scalaxb.toXML[xmltv.Title](_, None, Some("title"), __scope, false) },
        __obj.subu45title flatMap { scalaxb.toXML[xmltv.Subu45title](_, None, Some("sub-title"), __scope, false) },
        __obj.desc flatMap { scalaxb.toXML[xmltv.Desc](_, None, Some("desc"), __scope, false) },
        __obj.credits map { scalaxb.toXML[xmltv.Credits](_, None, Some("credits"), __scope, false) } getOrElse {Nil},
        __obj.date map { scalaxb.toXML[String](_, None, Some("date"), __scope, false) } getOrElse {Nil},
        __obj.category flatMap { scalaxb.toXML[xmltv.Category](_, None, Some("category"), __scope, false) },
        __obj.language map { scalaxb.toXML[xmltv.Language](_, None, Some("language"), __scope, false) } getOrElse {Nil},
        __obj.origu45language map { scalaxb.toXML[xmltv.Origu45language](_, None, Some("orig-language"), __scope, false) } getOrElse {Nil},
        __obj.length map { scalaxb.toXML[xmltv.Length](_, None, Some("length"), __scope, false) } getOrElse {Nil},
        __obj.icon flatMap { scalaxb.toXML[xmltv.Icon](_, None, Some("icon"), __scope, false) })


  }

  trait DefaultXmltvProgrammeSequence2Format extends scalaxb.XMLFormat[xmltv.ProgrammeSequence2] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, xmltv.ProgrammeSequence2] = Left("don't call me.")
    
    def writes(__obj: xmltv.ProgrammeSequence2, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(__obj.url flatMap { scalaxb.toXML[String](_, None, Some("url"), __scope, false) },
        __obj.country flatMap { scalaxb.toXML[xmltv.Country](_, None, Some("country"), __scope, false) },
        __obj.episodeu45num flatMap { scalaxb.toXML[xmltv.Episodeu45num](_, None, Some("episode-num"), __scope, false) },
        __obj.video map { scalaxb.toXML[xmltv.Video](_, None, Some("video"), __scope, false) } getOrElse {Nil},
        __obj.audio map { scalaxb.toXML[xmltv.Audio](_, None, Some("audio"), __scope, false) } getOrElse {Nil},
        __obj.previouslyu45shown map { scalaxb.toXML[xmltv.Previouslyu45shown](_, None, Some("previously-shown"), __scope, false) } getOrElse {Nil},
        __obj.premiere map { scalaxb.toXML[xmltv.Premiere](_, None, Some("premiere"), __scope, false) } getOrElse {Nil},
        __obj.lastu45chance map { scalaxb.toXML[xmltv.Lastu45chance](_, None, Some("last-chance"), __scope, false) } getOrElse {Nil},
        __obj.newValue map { scalaxb.toXML[xmltv.New](_, None, Some("new"), __scope, false) } getOrElse {Nil},
        __obj.subtitles flatMap { scalaxb.toXML[xmltv.Subtitles](_, None, Some("subtitles"), __scope, false) })


  }

  trait DefaultXmltvProgrammeSequence3Format extends scalaxb.XMLFormat[xmltv.ProgrammeSequence3] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, xmltv.ProgrammeSequence3] = Left("don't call me.")
    
    def writes(__obj: xmltv.ProgrammeSequence3, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(__obj.rating flatMap { scalaxb.toXML[xmltv.Rating](_, None, Some("rating"), __scope, false) },
        __obj.staru45rating flatMap { scalaxb.toXML[xmltv.Staru45rating](_, None, Some("star-rating"), __scope, false) },
        __obj.review flatMap { scalaxb.toXML[xmltv.Review](_, None, Some("review"), __scope, false) })


  }

  trait DefaultXmltvTitleFormat extends scalaxb.ElemNameParser[xmltv.Title] {
    val targetNamespace: Option[String] = None
    
    override def isMixed: Boolean = true

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[xmltv.Title] =
      phrase(optTextRecord ^^
      { case p1 =>
      xmltv.Title(Seq.concat(p1.toList),
        (node \ "@lang").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }) })
    
    override def writesAttribute(__obj: xmltv.Title, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.lang foreach { x => attr = scala.xml.Attribute(null, "lang", x.toString, attr) }
      attr
    }
    def writesChildNodes(__obj: xmltv.Title, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      __obj.mixed.toSeq flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) }
  }

  trait DefaultXmltvSubu45titleFormat extends scalaxb.ElemNameParser[xmltv.Subu45title] {
    val targetNamespace: Option[String] = None
    
    override def isMixed: Boolean = true

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[xmltv.Subu45title] =
      phrase(optTextRecord ^^
      { case p1 =>
      xmltv.Subu45title(Seq.concat(p1.toList),
        (node \ "@lang").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }) })
    
    override def writesAttribute(__obj: xmltv.Subu45title, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.lang foreach { x => attr = scala.xml.Attribute(null, "lang", x.toString, attr) }
      attr
    }
    def writesChildNodes(__obj: xmltv.Subu45title, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      __obj.mixed.toSeq flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) }
  }

  trait DefaultXmltvDescFormat extends scalaxb.ElemNameParser[xmltv.Desc] {
    val targetNamespace: Option[String] = None
    
    override def isMixed: Boolean = true

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[xmltv.Desc] =
      phrase(optTextRecord ^^
      { case p1 =>
      xmltv.Desc(Seq.concat(p1.toList),
        (node \ "@lang").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }) })
    
    override def writesAttribute(__obj: xmltv.Desc, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.lang foreach { x => attr = scala.xml.Attribute(null, "lang", x.toString, attr) }
      attr
    }
    def writesChildNodes(__obj: xmltv.Desc, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      __obj.mixed.toSeq flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) }
  }

  trait DefaultXmltvCreditsFormat extends scalaxb.ElemNameParser[xmltv.Credits] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[xmltv.Credits] =
      phrase(rep(scalaxb.ElemName(None, "director")) ~ 
      rep(scalaxb.ElemName(None, "actor")) ~ 
      rep(scalaxb.ElemName(None, "writer")) ~ 
      rep(scalaxb.ElemName(None, "adapter")) ~ 
      rep(scalaxb.ElemName(None, "producer")) ~ 
      rep(scalaxb.ElemName(None, "composer")) ~ 
      rep(scalaxb.ElemName(None, "editor")) ~ 
      rep(scalaxb.ElemName(None, "presenter")) ~ 
      rep(scalaxb.ElemName(None, "commentator")) ~ 
      rep(scalaxb.ElemName(None, "guest")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 ~ p9 ~ p10 =>
      xmltv.Credits(p1.toSeq map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        p2.toSeq map { scalaxb.fromXML[xmltv.Actor](_, scalaxb.ElemName(node) :: stack) },
        p3.toSeq map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        p4.toSeq map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        p5.toSeq map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        p6.toSeq map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        p7.toSeq map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        p8.toSeq map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        p9.toSeq map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        p10.toSeq map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: xmltv.Credits, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.director flatMap { scalaxb.toXML[String](_, None, Some("director"), __scope, false) },
        __obj.actor flatMap { scalaxb.toXML[xmltv.Actor](_, None, Some("actor"), __scope, false) },
        __obj.writer flatMap { scalaxb.toXML[String](_, None, Some("writer"), __scope, false) },
        __obj.adapter flatMap { scalaxb.toXML[String](_, None, Some("adapter"), __scope, false) },
        __obj.producer flatMap { scalaxb.toXML[String](_, None, Some("producer"), __scope, false) },
        __obj.composer flatMap { scalaxb.toXML[String](_, None, Some("composer"), __scope, false) },
        __obj.editor flatMap { scalaxb.toXML[String](_, None, Some("editor"), __scope, false) },
        __obj.presenter flatMap { scalaxb.toXML[String](_, None, Some("presenter"), __scope, false) },
        __obj.commentator flatMap { scalaxb.toXML[String](_, None, Some("commentator"), __scope, false) },
        __obj.guest flatMap { scalaxb.toXML[String](_, None, Some("guest"), __scope, false) })

  }

  trait DefaultXmltvActorFormat extends scalaxb.ElemNameParser[xmltv.Actor] {
    val targetNamespace: Option[String] = None
    
    override def isMixed: Boolean = true

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[xmltv.Actor] =
      phrase(optTextRecord ^^
      { case p1 =>
      xmltv.Actor(Seq.concat(p1.toList),
        (node \ "@role").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }) })
    
    override def writesAttribute(__obj: xmltv.Actor, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.role foreach { x => attr = scala.xml.Attribute(null, "role", x.toString, attr) }
      attr
    }
    def writesChildNodes(__obj: xmltv.Actor, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      __obj.mixed.toSeq flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) }
  }

  trait DefaultXmltvCategoryFormat extends scalaxb.ElemNameParser[xmltv.Category] {
    val targetNamespace: Option[String] = None
    
    override def isMixed: Boolean = true

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[xmltv.Category] =
      phrase(optTextRecord ^^
      { case p1 =>
      xmltv.Category(Seq.concat(p1.toList),
        (node \ "@lang").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }) })
    
    override def writesAttribute(__obj: xmltv.Category, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.lang foreach { x => attr = scala.xml.Attribute(null, "lang", x.toString, attr) }
      attr
    }
    def writesChildNodes(__obj: xmltv.Category, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      __obj.mixed.toSeq flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) }
  }

  trait DefaultXmltvLanguageFormat extends scalaxb.ElemNameParser[xmltv.Language] {
    val targetNamespace: Option[String] = None
    
    override def isMixed: Boolean = true

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[xmltv.Language] =
      phrase(optTextRecord ^^
      { case p1 =>
      xmltv.Language(Seq.concat(p1.toList),
        (node \ "@lang").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }) })
    
    override def writesAttribute(__obj: xmltv.Language, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.lang foreach { x => attr = scala.xml.Attribute(null, "lang", x.toString, attr) }
      attr
    }
    def writesChildNodes(__obj: xmltv.Language, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      __obj.mixed.toSeq flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) }
  }

  trait DefaultXmltvOrigu45languageFormat extends scalaxb.ElemNameParser[xmltv.Origu45language] {
    val targetNamespace: Option[String] = None
    
    override def isMixed: Boolean = true

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[xmltv.Origu45language] =
      phrase(optTextRecord ^^
      { case p1 =>
      xmltv.Origu45language(Seq.concat(p1.toList),
        (node \ "@lang").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }) })
    
    override def writesAttribute(__obj: xmltv.Origu45language, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.lang foreach { x => attr = scala.xml.Attribute(null, "lang", x.toString, attr) }
      attr
    }
    def writesChildNodes(__obj: xmltv.Origu45language, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      __obj.mixed.toSeq flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) }
  }

  trait DefaultXmltvLengthFormat extends scalaxb.ElemNameParser[xmltv.Length] {
    val targetNamespace: Option[String] = None
    
    override def isMixed: Boolean = true

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[xmltv.Length] =
      phrase(optTextRecord ^^
      { case p1 =>
      xmltv.Length(Seq.concat(p1.toList),
        scalaxb.fromXML[xmltv.Units]((node \ "@units"), scalaxb.ElemName(node) :: stack)) })
    
    override def writesAttribute(__obj: xmltv.Length, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "units", __obj.units.toString, attr)
      attr
    }
    def writesChildNodes(__obj: xmltv.Length, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      __obj.mixed.toSeq flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) }
  }

  def buildXmltvUnitsFormat = new DefaultXmltvUnitsFormat {}
  trait DefaultXmltvUnitsFormat extends scalaxb.XMLFormat[xmltv.Units] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, xmltv.Units] = seq match {
      case elem: scala.xml.Elem => Right(xmltv.Units.fromString(elem.text, elem.scope))
      case _ => Right(xmltv.Units.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: xmltv.Units, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, scala.xml.Text(__obj.toString))
  }
  trait DefaultXmltvIconFormat extends scalaxb.XMLFormat[xmltv.Icon] with scalaxb.CanWriteChildNodes[xmltv.Icon] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, xmltv.Icon] = seq match {
      case node: scala.xml.Node => Right(xmltv.Icon(scalaxb.fromXML[String]((node \ "@src"), scalaxb.ElemName(node) :: stack),
        (node \ "@width").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@height").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: xmltv.Icon, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "src", __obj.src.toString, attr)
      __obj.width foreach { x => attr = scala.xml.Attribute(null, "width", x.toString, attr) }
      __obj.height foreach { x => attr = scala.xml.Attribute(null, "height", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: xmltv.Icon, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil

  }

  trait DefaultXmltvCountryFormat extends scalaxb.ElemNameParser[xmltv.Country] {
    val targetNamespace: Option[String] = None
    
    override def isMixed: Boolean = true

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[xmltv.Country] =
      phrase(optTextRecord ^^
      { case p1 =>
      xmltv.Country(Seq.concat(p1.toList),
        (node \ "@lang").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }) })
    
    override def writesAttribute(__obj: xmltv.Country, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.lang foreach { x => attr = scala.xml.Attribute(null, "lang", x.toString, attr) }
      attr
    }
    def writesChildNodes(__obj: xmltv.Country, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      __obj.mixed.toSeq flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) }
  }

  trait DefaultXmltvEpisodeu45numFormat extends scalaxb.ElemNameParser[xmltv.Episodeu45num] {
    val targetNamespace: Option[String] = None
    
    override def isMixed: Boolean = true

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[xmltv.Episodeu45num] =
      phrase(optTextRecord ^^
      { case p1 =>
      xmltv.Episodeu45num(Seq.concat(p1.toList),
        (node \ "@system").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[String](scala.xml.Text("onscreen"), scalaxb.ElemName(node) :: stack) }) })
    
    override def writesAttribute(__obj: xmltv.Episodeu45num, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      if (__obj.system.toString != "onscreen") attr = scala.xml.Attribute(null, "system", __obj.system.toString, attr)
      attr
    }
    def writesChildNodes(__obj: xmltv.Episodeu45num, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      __obj.mixed.toSeq flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) }
  }

  trait DefaultXmltvVideoFormat extends scalaxb.ElemNameParser[xmltv.Video] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[xmltv.Video] =
      phrase(opt(scalaxb.ElemName(None, "present")) ~ 
      opt(scalaxb.ElemName(None, "colour")) ~ 
      opt(scalaxb.ElemName(None, "aspect")) ~ 
      opt(scalaxb.ElemName(None, "quality")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      xmltv.Video(p1.headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        p3.headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        p4.headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: xmltv.Video, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.present map { scalaxb.toXML[String](_, None, Some("present"), __scope, false) } getOrElse {Nil},
        __obj.colour map { scalaxb.toXML[String](_, None, Some("colour"), __scope, false) } getOrElse {Nil},
        __obj.aspect map { scalaxb.toXML[String](_, None, Some("aspect"), __scope, false) } getOrElse {Nil},
        __obj.quality map { scalaxb.toXML[String](_, None, Some("quality"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultXmltvAudioFormat extends scalaxb.ElemNameParser[xmltv.Audio] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[xmltv.Audio] =
      phrase(opt(scalaxb.ElemName(None, "present")) ~ 
      opt(scalaxb.ElemName(None, "stereo")) ^^
      { case p1 ~ p2 =>
      xmltv.Audio(p1.headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: xmltv.Audio, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.present map { scalaxb.toXML[String](_, None, Some("present"), __scope, false) } getOrElse {Nil},
        __obj.stereo map { scalaxb.toXML[String](_, None, Some("stereo"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultXmltvPreviouslyu45shownFormat extends scalaxb.XMLFormat[xmltv.Previouslyu45shown] with scalaxb.CanWriteChildNodes[xmltv.Previouslyu45shown] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, xmltv.Previouslyu45shown] = seq match {
      case node: scala.xml.Node => Right(xmltv.Previouslyu45shown((node \ "@start").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@channel").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: xmltv.Previouslyu45shown, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.start foreach { x => attr = scala.xml.Attribute(null, "start", x.toString, attr) }
      __obj.channel foreach { x => attr = scala.xml.Attribute(null, "channel", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: xmltv.Previouslyu45shown, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil

  }

  trait DefaultXmltvPremiereFormat extends scalaxb.ElemNameParser[xmltv.Premiere] {
    val targetNamespace: Option[String] = None
    
    override def isMixed: Boolean = true

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[xmltv.Premiere] =
      phrase(optTextRecord ^^
      { case p1 =>
      xmltv.Premiere(Seq.concat(p1.toList),
        (node \ "@lang").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }) })
    
    override def writesAttribute(__obj: xmltv.Premiere, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.lang foreach { x => attr = scala.xml.Attribute(null, "lang", x.toString, attr) }
      attr
    }
    def writesChildNodes(__obj: xmltv.Premiere, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      __obj.mixed.toSeq flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) }
  }

  trait DefaultXmltvLastu45chanceFormat extends scalaxb.ElemNameParser[xmltv.Lastu45chance] {
    val targetNamespace: Option[String] = None
    
    override def isMixed: Boolean = true

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[xmltv.Lastu45chance] =
      phrase(optTextRecord ^^
      { case p1 =>
      xmltv.Lastu45chance(Seq.concat(p1.toList),
        (node \ "@lang").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }) })
    
    override def writesAttribute(__obj: xmltv.Lastu45chance, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.lang foreach { x => attr = scala.xml.Attribute(null, "lang", x.toString, attr) }
      attr
    }
    def writesChildNodes(__obj: xmltv.Lastu45chance, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      __obj.mixed.toSeq flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) }
  }

  trait DefaultXmltvNewFormat extends scalaxb.XMLFormat[xmltv.New] with scalaxb.CanWriteChildNodes[xmltv.New] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, xmltv.New] = seq match {
      case node: scala.xml.Node => Right(xmltv.New())
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def writesChildNodes(__obj: xmltv.New, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil

  }
  trait DefaultXmltvSubtitlesFormat extends scalaxb.ElemNameParser[xmltv.Subtitles] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[xmltv.Subtitles] =
      phrase(opt(scalaxb.ElemName(None, "language")) ^^
      { case p1 =>
      xmltv.Subtitles(p1.headOption map { scalaxb.fromXML[xmltv.Language](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@type").headOption map { scalaxb.fromXML[xmltv.Type](_, scalaxb.ElemName(node) :: stack) }) })
    
    override def writesAttribute(__obj: xmltv.Subtitles, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.typeValue foreach { x => attr = scala.xml.Attribute(null, "type", x.toString, attr) }
      attr
    }
    def writesChildNodes(__obj: xmltv.Subtitles, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.language map { scalaxb.toXML[xmltv.Language](_, None, Some("language"), __scope, false) } getOrElse {Nil})
  }

  def buildXmltvTypeFormat = new DefaultXmltvTypeFormat {}
  trait DefaultXmltvTypeFormat extends scalaxb.XMLFormat[xmltv.Type] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, xmltv.Type] = seq match {
      case elem: scala.xml.Elem => Right(xmltv.Type.fromString(elem.text, elem.scope))
      case _ => Right(xmltv.Type.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: xmltv.Type, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, scala.xml.Text(__obj.toString))
  }
  trait DefaultXmltvRatingFormat extends scalaxb.ElemNameParser[xmltv.Rating] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[xmltv.Rating] =
      phrase((scalaxb.ElemName(None, "value")) ~ 
      rep(scalaxb.ElemName(None, "icon")) ^^
      { case p1 ~ p2 =>
      xmltv.Rating(scalaxb.fromXML[String](p1, scalaxb.ElemName(node) :: stack),
        p2.toSeq map { scalaxb.fromXML[xmltv.Icon](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@system").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }) })
    
    override def writesAttribute(__obj: xmltv.Rating, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.system foreach { x => attr = scala.xml.Attribute(null, "system", x.toString, attr) }
      attr
    }
    def writesChildNodes(__obj: xmltv.Rating, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(scalaxb.toXML[String](__obj.value, None, Some("value"), __scope, false),
        __obj.icon flatMap { scalaxb.toXML[xmltv.Icon](_, None, Some("icon"), __scope, false) })

  }

  trait DefaultXmltvStaru45ratingFormat extends scalaxb.ElemNameParser[xmltv.Staru45rating] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[xmltv.Staru45rating] =
      phrase((scalaxb.ElemName(None, "value")) ~ 
      rep(scalaxb.ElemName(None, "icon")) ^^
      { case p1 ~ p2 =>
      xmltv.Staru45rating(scalaxb.fromXML[String](p1, scalaxb.ElemName(node) :: stack),
        p2.toSeq map { scalaxb.fromXML[xmltv.Icon](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@system").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }) })
    
    override def writesAttribute(__obj: xmltv.Staru45rating, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.system foreach { x => attr = scala.xml.Attribute(null, "system", x.toString, attr) }
      attr
    }
    def writesChildNodes(__obj: xmltv.Staru45rating, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(scalaxb.toXML[String](__obj.value, None, Some("value"), __scope, false),
        __obj.icon flatMap { scalaxb.toXML[xmltv.Icon](_, None, Some("icon"), __scope, false) })

  }

  trait DefaultXmltvReviewFormat extends scalaxb.ElemNameParser[xmltv.Review] {
    val targetNamespace: Option[String] = None
    
    override def isMixed: Boolean = true

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[xmltv.Review] =
      phrase(optTextRecord ^^
      { case p1 =>
      xmltv.Review(Seq.concat(p1.toList),
        scalaxb.fromXML[xmltv.TypeType]((node \ "@type"), scalaxb.ElemName(node) :: stack),
        (node \ "@source").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@reviewer").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@lang").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }) })
    
    override def writesAttribute(__obj: xmltv.Review, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
      __obj.source foreach { x => attr = scala.xml.Attribute(null, "source", x.toString, attr) }
      __obj.reviewer foreach { x => attr = scala.xml.Attribute(null, "reviewer", x.toString, attr) }
      __obj.lang foreach { x => attr = scala.xml.Attribute(null, "lang", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: xmltv.Review, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      __obj.mixed.toSeq flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) }
  }

  def buildXmltvTypeTypeFormat = new DefaultXmltvTypeTypeFormat {}
  trait DefaultXmltvTypeTypeFormat extends scalaxb.XMLFormat[xmltv.TypeType] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, xmltv.TypeType] = seq match {
      case elem: scala.xml.Elem => Right(xmltv.TypeType.fromString(elem.text, elem.scope))
      case _ => Right(xmltv.TypeType.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: xmltv.TypeType, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, scala.xml.Text(__obj.toString))
  }
  trait DefaultXmltvAttlistu46reviewFormat extends scalaxb.AttributeGroupFormat[xmltv.Attlistu46review] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, xmltv.Attlistu46review] = seq match {
      case node: scala.xml.Node => Right(xmltv.Attlistu46review(scalaxb.fromXML[xmltv.TypeType]((node \ "@type"), scalaxb.ElemName(node) :: stack),
      (node \ "@source").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@reviewer").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@lang").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: xmltv.Attlistu46review, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
    __obj.source foreach { x => attr = scala.xml.Attribute(null, "source", x.toString, attr) }
    __obj.reviewer foreach { x => attr = scala.xml.Attribute(null, "reviewer", x.toString, attr) }
    __obj.lang foreach { x => attr = scala.xml.Attribute(null, "lang", x.toString, attr) }
      attr
    }
  }

  trait DefaultXmltvAttlistu46staru45ratingFormat extends scalaxb.AttributeGroupFormat[xmltv.Attlistu46staru45rating] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, xmltv.Attlistu46staru45rating] = seq match {
      case node: scala.xml.Node => Right(xmltv.Attlistu46staru45rating((node \ "@system").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: xmltv.Attlistu46staru45rating, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      __obj.system foreach { x => attr = scala.xml.Attribute(null, "system", x.toString, attr) }
      attr
    }
  }
  trait DefaultXmltvAttlistu46ratingFormat extends scalaxb.AttributeGroupFormat[xmltv.Attlistu46rating] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, xmltv.Attlistu46rating] = seq match {
      case node: scala.xml.Node => Right(xmltv.Attlistu46rating((node \ "@system").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: xmltv.Attlistu46rating, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      __obj.system foreach { x => attr = scala.xml.Attribute(null, "system", x.toString, attr) }
      attr
    }
  }
  trait DefaultXmltvAttlistu46subtitlesFormat extends scalaxb.AttributeGroupFormat[xmltv.Attlistu46subtitles] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, xmltv.Attlistu46subtitles] = seq match {
      case node: scala.xml.Node => Right(xmltv.Attlistu46subtitles((node \ "@type").headOption map { scalaxb.fromXML[xmltv.Type](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: xmltv.Attlistu46subtitles, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      __obj.typeValue foreach { x => attr = scala.xml.Attribute(null, "type", x.toString, attr) }
      attr
    }
  }
  trait DefaultXmltvAttlistu46lastu45chanceFormat extends scalaxb.AttributeGroupFormat[xmltv.Attlistu46lastu45chance] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, xmltv.Attlistu46lastu45chance] = seq match {
      case node: scala.xml.Node => Right(xmltv.Attlistu46lastu45chance((node \ "@lang").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: xmltv.Attlistu46lastu45chance, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      __obj.lang foreach { x => attr = scala.xml.Attribute(null, "lang", x.toString, attr) }
      attr
    }
  }
  trait DefaultXmltvAttlistu46premiereFormat extends scalaxb.AttributeGroupFormat[xmltv.Attlistu46premiere] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, xmltv.Attlistu46premiere] = seq match {
      case node: scala.xml.Node => Right(xmltv.Attlistu46premiere((node \ "@lang").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: xmltv.Attlistu46premiere, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      __obj.lang foreach { x => attr = scala.xml.Attribute(null, "lang", x.toString, attr) }
      attr
    }
  }
  trait DefaultXmltvAttlistu46previouslyu45shownFormat extends scalaxb.AttributeGroupFormat[xmltv.Attlistu46previouslyu45shown] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, xmltv.Attlistu46previouslyu45shown] = seq match {
      case node: scala.xml.Node => Right(xmltv.Attlistu46previouslyu45shown((node \ "@start").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@channel").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: xmltv.Attlistu46previouslyu45shown, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      __obj.start foreach { x => attr = scala.xml.Attribute(null, "start", x.toString, attr) }
    __obj.channel foreach { x => attr = scala.xml.Attribute(null, "channel", x.toString, attr) }
      attr
    }
  }

  trait DefaultXmltvAttlistu46episodeu45numFormat extends scalaxb.AttributeGroupFormat[xmltv.Attlistu46episodeu45num] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, xmltv.Attlistu46episodeu45num] = seq match {
      case node: scala.xml.Node => Right(xmltv.Attlistu46episodeu45num((node \ "@system").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[String](scala.xml.Text("onscreen"), scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: xmltv.Attlistu46episodeu45num, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      if (__obj.system.toString != "onscreen") attr = scala.xml.Attribute(null, "system", __obj.system.toString, attr)
      attr
    }
  }
  trait DefaultXmltvAttlistu46countryFormat extends scalaxb.AttributeGroupFormat[xmltv.Attlistu46country] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, xmltv.Attlistu46country] = seq match {
      case node: scala.xml.Node => Right(xmltv.Attlistu46country((node \ "@lang").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: xmltv.Attlistu46country, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      __obj.lang foreach { x => attr = scala.xml.Attribute(null, "lang", x.toString, attr) }
      attr
    }
  }
  trait DefaultXmltvAttlistu46iconFormat extends scalaxb.AttributeGroupFormat[xmltv.Attlistu46icon] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, xmltv.Attlistu46icon] = seq match {
      case node: scala.xml.Node => Right(xmltv.Attlistu46icon(scalaxb.fromXML[String]((node \ "@src"), scalaxb.ElemName(node) :: stack),
      (node \ "@width").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@height").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: xmltv.Attlistu46icon, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      attr = scala.xml.Attribute(null, "src", __obj.src.toString, attr)
    __obj.width foreach { x => attr = scala.xml.Attribute(null, "width", x.toString, attr) }
    __obj.height foreach { x => attr = scala.xml.Attribute(null, "height", x.toString, attr) }
      attr
    }
  }

  trait DefaultXmltvAttlistu46lengthFormat extends scalaxb.AttributeGroupFormat[xmltv.Attlistu46length] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, xmltv.Attlistu46length] = seq match {
      case node: scala.xml.Node => Right(xmltv.Attlistu46length(scalaxb.fromXML[xmltv.Units]((node \ "@units"), scalaxb.ElemName(node) :: stack)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: xmltv.Attlistu46length, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      attr = scala.xml.Attribute(null, "units", __obj.units.toString, attr)
      attr
    }
  }
  trait DefaultXmltvAttlistu46origu45languageFormat extends scalaxb.AttributeGroupFormat[xmltv.Attlistu46origu45language] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, xmltv.Attlistu46origu45language] = seq match {
      case node: scala.xml.Node => Right(xmltv.Attlistu46origu45language((node \ "@lang").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: xmltv.Attlistu46origu45language, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      __obj.lang foreach { x => attr = scala.xml.Attribute(null, "lang", x.toString, attr) }
      attr
    }
  }
  trait DefaultXmltvAttlistu46languageFormat extends scalaxb.AttributeGroupFormat[xmltv.Attlistu46language] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, xmltv.Attlistu46language] = seq match {
      case node: scala.xml.Node => Right(xmltv.Attlistu46language((node \ "@lang").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: xmltv.Attlistu46language, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      __obj.lang foreach { x => attr = scala.xml.Attribute(null, "lang", x.toString, attr) }
      attr
    }
  }
  trait DefaultXmltvAttlistu46categoryFormat extends scalaxb.AttributeGroupFormat[xmltv.Attlistu46category] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, xmltv.Attlistu46category] = seq match {
      case node: scala.xml.Node => Right(xmltv.Attlistu46category((node \ "@lang").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: xmltv.Attlistu46category, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      __obj.lang foreach { x => attr = scala.xml.Attribute(null, "lang", x.toString, attr) }
      attr
    }
  }
  trait DefaultXmltvAttlistu46actorFormat extends scalaxb.AttributeGroupFormat[xmltv.Attlistu46actor] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, xmltv.Attlistu46actor] = seq match {
      case node: scala.xml.Node => Right(xmltv.Attlistu46actor((node \ "@role").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: xmltv.Attlistu46actor, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      __obj.role foreach { x => attr = scala.xml.Attribute(null, "role", x.toString, attr) }
      attr
    }
  }
  trait DefaultXmltvAttlistu46descFormat extends scalaxb.AttributeGroupFormat[xmltv.Attlistu46desc] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, xmltv.Attlistu46desc] = seq match {
      case node: scala.xml.Node => Right(xmltv.Attlistu46desc((node \ "@lang").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: xmltv.Attlistu46desc, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      __obj.lang foreach { x => attr = scala.xml.Attribute(null, "lang", x.toString, attr) }
      attr
    }
  }
  trait DefaultXmltvAttlistu46subu45titleFormat extends scalaxb.AttributeGroupFormat[xmltv.Attlistu46subu45title] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, xmltv.Attlistu46subu45title] = seq match {
      case node: scala.xml.Node => Right(xmltv.Attlistu46subu45title((node \ "@lang").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: xmltv.Attlistu46subu45title, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      __obj.lang foreach { x => attr = scala.xml.Attribute(null, "lang", x.toString, attr) }
      attr
    }
  }
  trait DefaultXmltvAttlistu46titleFormat extends scalaxb.AttributeGroupFormat[xmltv.Attlistu46title] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, xmltv.Attlistu46title] = seq match {
      case node: scala.xml.Node => Right(xmltv.Attlistu46title((node \ "@lang").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: xmltv.Attlistu46title, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      __obj.lang foreach { x => attr = scala.xml.Attribute(null, "lang", x.toString, attr) }
      attr
    }
  }
  trait DefaultXmltvAttlistu46programmeFormat extends scalaxb.AttributeGroupFormat[xmltv.Attlistu46programme] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, xmltv.Attlistu46programme] = seq match {
      case node: scala.xml.Node => Right(xmltv.Attlistu46programme(scalaxb.fromXML[String]((node \ "@start"), scalaxb.ElemName(node) :: stack),
      (node \ "@stop").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@pdc-start").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@vps-start").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@showview").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@videoplus").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
      scalaxb.fromXML[String]((node \ "@channel"), scalaxb.ElemName(node) :: stack),
      (node \ "@clumpidx").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[String](scala.xml.Text("0/1"), scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: xmltv.Attlistu46programme, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      attr = scala.xml.Attribute(null, "start", __obj.start.toString, attr)
    __obj.stop foreach { x => attr = scala.xml.Attribute(null, "stop", x.toString, attr) }
    __obj.pdcu45start foreach { x => attr = scala.xml.Attribute(null, "pdc-start", x.toString, attr) }
    __obj.vpsu45start foreach { x => attr = scala.xml.Attribute(null, "vps-start", x.toString, attr) }
    __obj.showview foreach { x => attr = scala.xml.Attribute(null, "showview", x.toString, attr) }
    __obj.videoplus foreach { x => attr = scala.xml.Attribute(null, "videoplus", x.toString, attr) }
    attr = scala.xml.Attribute(null, "channel", __obj.channel.toString, attr)
    if (__obj.clumpidx.toString != "0/1") attr = scala.xml.Attribute(null, "clumpidx", __obj.clumpidx.toString, attr)
      attr
    }
  }

  trait DefaultXmltvAttlistu46displayu45nameFormat extends scalaxb.AttributeGroupFormat[xmltv.Attlistu46displayu45name] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, xmltv.Attlistu46displayu45name] = seq match {
      case node: scala.xml.Node => Right(xmltv.Attlistu46displayu45name((node \ "@lang").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: xmltv.Attlistu46displayu45name, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      __obj.lang foreach { x => attr = scala.xml.Attribute(null, "lang", x.toString, attr) }
      attr
    }
  }
  trait DefaultXmltvAttlistu46channelFormat extends scalaxb.AttributeGroupFormat[xmltv.Attlistu46channel] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, xmltv.Attlistu46channel] = seq match {
      case node: scala.xml.Node => Right(xmltv.Attlistu46channel(scalaxb.fromXML[String]((node \ "@id"), scalaxb.ElemName(node) :: stack)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: xmltv.Attlistu46channel, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      attr = scala.xml.Attribute(null, "id", __obj.id.toString, attr)
      attr
    }
  }
  trait DefaultXmltvAttlistu46tvFormat extends scalaxb.AttributeGroupFormat[xmltv.Attlistu46tv] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, xmltv.Attlistu46tv] = seq match {
      case node: scala.xml.Node => Right(xmltv.Attlistu46tv((node \ "@date").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@source-info-url").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@source-info-name").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@source-data-url").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@generator-info-name").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@generator-info-url").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: xmltv.Attlistu46tv, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      __obj.date foreach { x => attr = scala.xml.Attribute(null, "date", x.toString, attr) }
    __obj.sourceu45infou45url foreach { x => attr = scala.xml.Attribute(null, "source-info-url", x.toString, attr) }
    __obj.sourceu45infou45name foreach { x => attr = scala.xml.Attribute(null, "source-info-name", x.toString, attr) }
    __obj.sourceu45datau45url foreach { x => attr = scala.xml.Attribute(null, "source-data-url", x.toString, attr) }
    __obj.generatoru45infou45name foreach { x => attr = scala.xml.Attribute(null, "generator-info-name", x.toString, attr) }
    __obj.generatoru45infou45url foreach { x => attr = scala.xml.Attribute(null, "generator-info-url", x.toString, attr) }
      attr
    }
  }


}

